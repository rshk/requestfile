"""
Build a Request from a Requestfile
"""

import io
import os
from collections import OrderedDict
from mimetypes import guess_type as guess_file_type
from urllib.parse import parse_qsl

from multidict import CIMultiDict

from requestfile.ast import (
    Argument,
    ArgValue,
    Command,
    Header,
    Heredoc,
    IncludedFile,
    QuotedValue,
    RawData,
    Requestfile,
    Symbol,
    Variable,
)
from requestfile.parser import _parse_header_line
from requestfile.utils.registry import Registry

from .context import BuilderContext, get_builder_context, set_builder_context
from .filters import get_filter
from .request import Field, PartData, Request, RequestContentType
from .resource_loader import BaseResourceLoader, ResourceLoader


def build_request(
    requestfile: Requestfile,
    variables: dict[str, str | bytes] | None = None,
    resource_loader: BaseResourceLoader | None = None,
) -> Request:
    """
    Create a Request object by evaluating a Requestfile.
    """

    if resource_loader is None:
        resource_loader = ResourceLoader(
            os.path.dirname(requestfile.source_filename)
            if requestfile.source_filename is not None
            else os.getcwd()
        )

    ctx = BuilderContext(
        requestfile=requestfile,
        request=None,
        variables=variables or {},
        resource_loader=resource_loader,
    )

    with set_builder_context(ctx):
        process_preamble_items(requestfile)

        ctx.request = Request(
            method=requestfile.requestline.method,
            url=eval_argument(ctx, requestfile.requestline.url_arg),
        )

        process_header_items(requestfile)
        process_body_items(requestfile)
        process_body_data(ctx.request)

    return ctx.request


def process_preamble_items(requestfile: Requestfile):
    ctx = get_builder_context()
    for item in requestfile.preamble:
        match item:
            case Command(_) as cmd:
                PREAMBLE_COMMANDS[cmd.name](ctx, cmd)
            case _:
                # Ignore comments and blank lines
                pass


def process_header_items(requestfile: Requestfile):
    ctx = get_builder_context()
    for item in requestfile.headers:
        match item:
            case Command(_) as cmd:
                HEADER_COMMANDS[cmd.name](ctx, cmd)
            case Header(name, value):
                ctx.request.headers.add(name, value)
            case _:
                # Ignore comments
                pass


def process_body_items(requestfile: Requestfile):
    """
    Evaluate commands to generate body data.

    This will also ugprade the content_type to FORM or MULTIPART as
    needed.
    """
    ctx = get_builder_context()
    for item in requestfile.body:
        match item:
            case Command(_) as cmd:
                BODY_COMMANDS[cmd.name](ctx, cmd)
            case RawData(value):
                ctx.request.body_data.append(value)
            case _:
                # Ignore comments and blank lines
                pass

    # Determine content type based on the data generated by evaluating
    # commands.
    ctx.request.content_type = determine_content_type(ctx.request)

    # Allow users to force a "higher" content type, if needed.
    # TODO: should we also set the Content-type header here, to ensure
    # the requested content type is actually used in the request?
    if (ct := requestfile.content_type) is not None:
        ctx.request.content_type = upgrade_content_type(
            ctx.request.content_type, RequestContentType(ct)
        )


def eval_arguments(
    ctx: BuilderContext, cmd: Command
) -> list[tuple[str | None, str | bytes]]:
    return [(arg.name, eval_argument(ctx, arg)) for arg in cmd.arguments]


def eval_argument(ctx: BuilderContext, arg: Argument) -> str | bytes:
    value = eval_argument_value(ctx, arg.value)

    # Apply filters
    for filter_def in arg.filters:
        filter_fn = get_filter(filter_def.name)
        value = filter_fn(value)

    return value


def eval_argument_value(ctx: BuilderContext, argvalue: ArgValue) -> str | bytes:
    if isinstance(argvalue, (Symbol, QuotedValue, Heredoc)):
        if argvalue.value is None:
            return ""
        return argvalue.value

    if isinstance(argvalue, IncludedFile):
        filename = argvalue.value.value
        return ctx.resource_loader.read_bytes(filename)

    if isinstance(argvalue, Variable):
        return ctx.variables[argvalue.value]

    # Unreachable
    raise TypeError(f"Unsupported argument value type: {argvalue}")


def determine_content_type(req: Request) -> RequestContentType:
    """
    Determine content type for a request.

    Analyze body data components to determine a suitable "content
    type" for the request.
    """

    capabilities = {
        "text_data": False,
        "binary_data": False,
        "form_data": False,
        "multipart_data": False,
    }

    for item in req.body_data:
        match item:
            case str():
                capabilities["text_data"] = True
            case bytes():
                capabilities["binary_data"] = True
            case Field(_):
                capabilities["form_data"] = True
            case PartData(_):
                capabilities["multipart_data"] = True
            case _:
                # Unreachable
                raise TypeError(f"Bad request body data item: {item}")

    if capabilities["multipart_data"]:
        return RequestContentType.MULTIPART
    if capabilities["form_data"]:
        return RequestContentType.FORM
    if capabilities["binary_data"]:
        return RequestContentType.BYTES
    return RequestContentType.TEXT


def upgrade_content_type(base: RequestContentType, other: RequestContentType):
    """
    Upgrade content type to a type that supports both.
    """

    # Kinda clumsy, but it's not guaranteed that other content_types
    # we might add in the future will also be as nicely ordered...

    match base:
        case RequestContentType.MULTIPART:
            return base

        case RequestContentType.FORM:
            if other == RequestContentType.MULTIPART:
                return other
            return base

        case RequestContentType.BYTES:
            if other in (RequestContentType.MULTIPART, RequestContentType.FORM):
                return other
            return base

        case RequestContentType.TEXT:
            if other in (
                RequestContentType.BYTES,
                RequestContentType.MULTIPART,
                RequestContentType.FORM,
            ):
                return other
            return base

        case _:
            # Unreachable
            raise ValueError(f"Unsupported: {base}")


def process_body_data(req: Request):
    """
    Process request body data.

    Post-process body data to populate fields and files.
    This is done in a second pass, as the initial pass is used to
    determine the content_type, which is used by the second pass to
    decide how to parse raw data.

    The outcome depends on the request content_type:

    - TEXT:
        Sets req.raw_body to a string, containing concatenated
        body_data.
    - BYTES:
        Sets req.raw_body to a bytes object, containing concatenated
        body_data.
    - FORM:
        Sets req.fields using the body data.
        Raw str/bytes will be parsed as form data.
    - MULTIPART:
        Sets req.fields and req.files using the body data.
        Raw str/bytes will be parsed as form data.
    """

    if req.content_type == RequestContentType.TEXT:
        result = io.StringIO()
        for item in req.body_data:
            if not isinstance(item, str):
                raise TypeError("Bad body_data for TEXT")
            result.write(item)
            result.write("\n")  # TODO: were should we add newlines?
        req.raw_body = result.getvalue()
        return

    if req.content_type == RequestContentType.BYTES:
        result = io.BytesIO()
        for item in req.body_data:
            if not isinstance(item, (str, bytes)):
                raise TypeError("Bad body_data for TEXT")
            if isinstance(item, str):
                item = item.encode()
            result.write(item)
            # No newline for binary data
        req.raw_body = result.getvalue()
        return

    if req.content_type in (RequestContentType.FORM, RequestContentType.MULTIPART):
        for item in req.body_data:
            match item:
                case Field(name, value):
                    req.fields[_ensure_str(name)] = value

                case PartData(_) as part:
                    assert req.content_type == RequestContentType.MULTIPART
                    req.files[_ensure_str(part.name)] = part

                case str():
                    for key, val in parse_qsl(item):
                        req.fields.add(key, val)

                case bytes():
                    for key, val in parse_qsl(item):
                        req.fields.add(key.decode(), val)

                case _:
                    # Unreachable
                    raise TypeError(f"Unsupported item: {item}")
        return

    raise ValueError(f"Unsupported content type: {req.content_type}")


PREAMBLE_COMMANDS = Registry()
HEADER_COMMANDS = Registry()
BODY_COMMANDS = Registry()


@PREAMBLE_COMMANDS.declare("set")
@HEADER_COMMANDS.declare("set")
@BODY_COMMANDS.declare("set")
def command_set(ctx: BuilderContext, cmd: Command):
    if len(cmd.arguments) != 2:
        raise ValueError("Invalid syntax. Expected: %SET: <name> <value>")
    args = eval_arguments(ctx, cmd)
    [(_, name), (_, value)] = args

    ctx.variables[_ensure_str(name)] = value


@PREAMBLE_COMMANDS.declare("set-default")
@HEADER_COMMANDS.declare("set-default")
@BODY_COMMANDS.declare("set-default")
def command_set_default(ctx: BuilderContext, cmd: Command):
    args = eval_arguments(ctx, cmd)
    if len(cmd.arguments) != 2:
        raise ValueError("Invalid syntax. Expected: %SET-DEFAULT: <name> <value>")
    args = eval_arguments(ctx, cmd)
    [(_, name), (_, value)] = args

    ctx.variables.setdefault(_ensure_str(name), value)


@PREAMBLE_COMMANDS.declare("param")
@HEADER_COMMANDS.declare("param")
def command_param(ctx: BuilderContext, cmd: Command):
    if len(cmd.arguments) != 2:
        raise ValueError("Invalid syntax. Expected: %PARAM: <name> <value>")
    args = eval_arguments(ctx, cmd)
    [(_, name), (_, value)] = args

    ctx.request.params.add(_ensure_str(name), value)


@HEADER_COMMANDS.declare("header")
def command_header(ctx: BuilderContext, cmd: Command):
    if len(cmd.arguments) != 2:
        raise ValueError("Invalid syntax. Expected: %HEADER: <name> <value>")
    args = eval_arguments(ctx, cmd)
    [(_, name), (_, value)] = args

    ctx.request.headers.add(_ensure_str(name), value)


@HEADER_COMMANDS.declare("cookie")
def command_cookie(ctx: BuilderContext, cmd: Command):
    if len(cmd.arguments) != 2:
        raise ValueError("Invalid syntax. Expected: %COOKIE: <name> <value>")
    args = eval_arguments(ctx, cmd)
    [(_, name), (_, value)] = args

    ctx.request.cookies.add(_ensure_str(name), value)


@BODY_COMMANDS.declare("include")
def command_include(ctx: BuilderContext, cmd: Command):
    if len(cmd.arguments) != 1:
        raise ValueError("Invalid syntax. Expected: %INCLUDE: <value>")
    args = eval_arguments(ctx, cmd)
    [(_, value)] = args

    ctx.request.body_data.append(value)


@BODY_COMMANDS.declare("field")
def command_field(ctx: BuilderContext, cmd: Command):
    if len(cmd.arguments) != 2:
        raise ValueError("Invalid syntax. Expected: %FIELD: <name> <value>")
    args = eval_arguments(ctx, cmd)
    [(_, name), (_, value)] = args

    field = Field(name, value)
    ctx.request.body_data.append(field)


@BODY_COMMANDS.declare("part")
def command_part(ctx: BuilderContext, cmd: Command):
    if len(cmd.arguments) < 2:
        raise ValueError("Invalid syntax. Expected: %PART: <name> [<args> ...] <value>")
    args = eval_arguments(ctx, cmd)

    (_, name) = args[0]
    (_, value) = args[-1]

    extra: dict[str, str | bytes | None] = OrderedDict(
        [
            ("mimetype", None),
            ("filename", None),
            ("headers", None),
        ]
    )

    # Assign command arguments to the correct argument.
    # TODO: make this into a generic function
    for argname, argvalue in args[1:-1]:
        if argname is None:
            # Positional argument: assign to the first free argument
            for k, v in extra.items():
                if v is None:
                    extra[k] = argvalue
                    break
            else:
                # Did not break -> all parameters are full
                raise ValueError("Too many arguments to %PART")
        else:
            # Named argument
            if argname not in extra:
                raise ValueError(f"Unknown argument to %PART: {argname}")
            if extra[argname] is not None:
                raise ValueError(
                    f"Argument to %PART specified multiple times: {argname}"
                )
            extra[argname] = argvalue

    mimetype = extra["mimetype"]
    filename = extra["filename"]
    headers = CIMultiDict()

    if mimetype is None or filename is None:
        # Try and guess mime type and file name from the original file
        value_argument = cmd.arguments[-1]
        if isinstance(obj := value_argument.value, IncludedFile):
            path = obj.value.value
            if filename is None:
                filename = os.path.basename(path)
            if mimetype is None:
                mimetype, _ = guess_file_type(path)

    if extra["headers"] is not None:
        # Parse headers data
        for line in extra["headers"].splitlines():
            if line.strip() == "":
                continue
            header = _parse_header_line(line)
            headers.add(header.name, header.value)

    part = PartData(
        name=name,
        mimetype=mimetype,
        filename=filename,
        headers=headers,
        body=value,
    )

    ctx.request.body_data.append(part)


def _ensure_str(text: str | bytes) -> str:
    if not isinstance(text, str):
        return text.decode()
    return text


def _ensure_bytes(data: str | bytes) -> bytes:
    if not isinstance(data, bytes):
        return data.encode()
    return data
